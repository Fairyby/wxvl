#  渗透测试|倒反天罡！转发给你的老师《0基础也能学渗透测试+代码审计电商平台靶场》让他重修  
原创 爱州  州弟学安全   2025-06-16 01:13  
  
****  
**本篇文章共 12000字+2视频，完全阅读全篇约 150 分钟 州弟学安全，只学有用的知识**  
  
## 前言  
  
    在前面我们开放了**应急响应**  
、**流量分析**  
、**渗透测试**  
(黑盒)靶场，本次我们来一篇关于渗透测试配合白盒(代码审计)的靶场来进行训练，由于近期收到大部分师傅加好友请求，也就是上一篇文章发布从**6月3日-6月10日**  
左右共有200+人加我，大部分都是基础薄弱的小白，所以本篇文章以及直播/录播视频会先从基础介入来从代码方面了解渗透测试的另外一个角度  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BR9UaFmgm9jTjbYCpOZVQsUPSJnzXYHn5Oiafz5hLviawaOJoiaqWEzdl4w/640?wx_fmt=png&from=appmsg "")  
  
  
**注意：渗透测试永远没有标准WP，谁能力大谁挖的漏洞就多，这个就是靶场的意义，本次是站在自己主观立场上写WP**  
  
    本次环境来源于电子商务系统常见的漏洞点进行复现(原生PHP)，漏洞稍微多一些，不过易于理解(本次仅介绍部分漏洞，其它自行挖掘)  
```
所需工具下载：https://pan.quark.cn/s/3bb99354f302  渗透SRC场景挖掘地址：http://111.119.241.115:18866/  E购有限公司上线了一款系统名为EshopPro 电商系统，先需要你进行渗透测试+代码审计，挖掘出相关的漏洞，当然如果你有精力，可以挖一下风险项，值得注意的是，挖掘出来的漏洞，需要对比源代码出具报告，你也可以通过白盒(代码审计)的方式进行挖掘到难以发现的漏洞，这是一款具有趣味的电子商务靶场，快来挑战吧  注意：渗透测试靶场没有标准答案WP，每个人的思路不一样，看谁技高一筹呢？  源代码需使用黑盒的方式进行获取(模拟实战中的泄露等环境)  请勿使用公司和客户单位网络扫描以及测试防止被标记及告警  原企业CMS靶场：10088端口已下线  靶场仅供训练，请勿非法利用，请遵守网络安全法，实战后果自负
```  
  
    在本次文章中仍然是采用直播+录播的方式以文字和PPT的形式进行讲解，一方面是锻炼我自己能力，另一方面是和大家实际沟通交流  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRtzhUOVQSKkxlGzxSzbJIicV4ia39QWjibmPfMP7DZntwxoNgyxooDxlVA/640?wx_fmt=png&from=appmsg "")  
  
- **环境均为自作，不针对任何现实环境，仅供学习参考，实战请遵循网络安全法**  
  
- **如您认为对您学习有了帮助，请一键三连**  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRa5sgJsibBqDicB7a3Z30SBvdlVpTMO6xIYbL9bHRxia218qVZ4HSgewicw/640?wx_fmt=png&from=appmsg "")  
  
## 流程复现  
  
**超详细的直播视频教学，建议观看，更能身临其境(共2.2小时)**  
  
**初学者建议从第一个视频开始看(有基础的直接看第二个)**  
  
  
****  
**第二个视频(共一小时20分钟)靶场代码审计渗透测试**  
  
### 基础理论篇  
#### HTTP协议  
  
**HTTP**  
 (HyperText Transfer Protocol) 是一种用于分布式、协作式和超媒体信息系统的应用层协议。它是万维网数据通信的基础，也是PHP Web应用与客户端浏览器通信的主要协议。  
- 基于请求/响应模型  
  
- 无状态协议（每个请求相互独立）  
  
- 可以传输任何类型的数据  
  
- 默认端口为80（HTTPS为443）  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRSibuWngUmzcicCELF4a38J87CjiaFlBxpNiaaIdsB86iae0tAyHztD15GSg/640?wx_fmt=png&from=appmsg "")  
  
  
    在以上图片中的浏览器控制台中看到加载的无论文本文件还是jpg、js、css、字体等都是基于http传输的，他们相互之间都是独立的，也印证了"**可以传输任何类型的数据**  
"的特征  
#### HTTP请求方法详解  
  
**GET方法**  
- 用于请求指定资源的数据  
  
- 参数附加在URL中，形如?param1=value1&param2=value2  
  
- 参数可见，长度受限（通常不超过2048字符）  
  
- 不应用于修改数据或发送敏感信息  
  
- 浏览器可以缓存、收藏和保留在历史记录中  
  
- 示例：http://example.com/search?keyword=php&page=1  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRq4rLRYedkkInP6TeWkCP4xaHzO4dkGYEZaAjGJhVVsVxe7CQoJOYCQ/640?wx_fmt=png&from=appmsg "")  
  
  
    通过前端的源代码看到在搜索商品的位置是使用的GET协议，可以尝试一下  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRO0TWlz4NsrH0yABFBPRKMffnOMg8NibtOxKUtVwXCdwSgtJjvia9c2FQ/640?wx_fmt=png&from=appmsg "")  
  
  
    我在搜索框输入了"1"  
，然后url里面出现了**search.php?keyword=1**  
，至于在页面显示的数据是前端输入的值发送到后端，后端携带sql语句查询的数据，然后返回至后端代码接着打印在前端  
  
**前端携带搜索值->值传入后端->后端进行搜索->响应结果到后端进行处理->打印在前端**  
  
**POST方法**  
- 用于向服务器提交数据  
  
- 参数包含在请求体中，不在URL中显示  
  
- 可传输大量数据，理论上没有大小限制  
  
- 适合发送敏感信息或修改服务器上的数据  
  
- 浏览器通常不缓存POST请求  
  
- 示例：登录表单、文件上传等  
  
    那么在这里我们常见的比如：**注册登录**  
，**发送信息**  
，**购买请求**  
，**文件上传**  
等这种需要大量数据的请求包  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRibiaDbOHMZXs4axIaveC9YRG2upZp7UoOX7gnFOepr0xPoVVSCg58JUw/640?wx_fmt=png&from=appmsg "")  
  
  
    比如上图，我这里进行了登录操作，那么请求头就是POST请求，请求体里面的内容就是账号和密码  
  
**其他重要方法**  
- **PUT**  
：用于更新服务器上的资源  
  
- **DELETE**  
：请求服务器删除指定资源  
  
- **HEAD**  
：与GET类似，但只返回响应头  
  
- **OPTIONS**  
：查询服务器支持的方法  
  
- **PATCH**  
：用于部分更新资源  
  
    以上可能在期末考或面试运维的适合会问到(这里仅针对与小白)  
#### 常见HTTP状态码(必学)  
- **1xx 信息性响应**  
：服务器已接收请求，需要进一步处理  
  
- **2xx 成功**  
：  
  
- 200 OK：请求成功  
  
- 201 Created：已创建新资源  
  
- **3xx 重定向**  
：  
  
- 301 Moved Permanently：永久重定向  
  
- 302 Found：临时重定向  
  
- 304 Not Modified：资源未修改，使用缓存  
  
- **4xx 客户端错误**  
：  
  
- 400 Bad Request：请求语法错误  
  
- 401 Unauthorized：未授权  
  
- 403 Forbidden：禁止访问  
  
- 404 Not Found：资源不存在  
  
- 405 Method Not Allowed：方法不允许  
  
- **5xx 服务器错误**  
：  
  
- 500 Internal Server Error：服务器内部错误  
  
- 502 Bad Gateway：网关错误  
  
- 503 Service Unavailable：服务不可用  
  
    以下为本次靶机简单举几个例子：  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRy8yKia3MBD2sOAD8jgRNeicXE8jRAWtDBy2sZYvIFE9Q3ZHQicprQQL7g/640?wx_fmt=png&from=appmsg "")  
  
  
    上图为初次访问站点地址，默认为index.php，200状态码表示访问成功(且文件存在)  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRJJGB8UWysicJRibyjVs0VrPPaESHllEJic1y9clf1fBU3pC6BpGS1LIPA/640?wx_fmt=png&from=appmsg "")  
  
  
    上图为登录请求，在输入了正确的账号和密码后，响应状态码为302，表示跳转至**index.php**  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRCDzJwdEZY2YcWbpJoic7eeoWc2WEWRlxfLUketgLb5mNHCGicBR9uLxA/640?wx_fmt=png&from=appmsg "")  
  
  
    同样的我们输入了错误的账号和密码，他显示200状态码而不是302，那么这就代表了页面只进行了刷新或直接渲染  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRsibyrPINQh6p9bjpMpRd8AJBrgicGZyKKWLQzx6abmVx26k1EQHx9PwA/640?wx_fmt=png&from=appmsg "")  
  
  
    接着，我们访问了一个不存在的文件，出现了**404**  
页面，这表示文件不存在，我在之前写的应急响应特征判断中其中可以看到，404可以作为特征判断扫描或爬虫  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRMXt4ubBXiaSO8X33qn9jvIoXdjGmjZibQJboLChia4Oh3ZoZh7bM6AYnQ/640?wx_fmt=png&from=appmsg "")  
  
  
    上图中我访问了其中一张图片，然后看状态码为304，这就是在初次我访问的时候缓存到本地了，不需要每次访问都加载，以减小压力  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRe1ME2vfomoNSNkBwvzMeGLUwoqjvibLW56rrMEcibDK1cxCjmMhMHPVQ/640?wx_fmt=png&from=appmsg "")  
  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRqDqwyLYEUmSRKOooYy5kmibLMZOWJNgjC9um9QS6ULcANGImS1icT7JA/640?wx_fmt=png&from=appmsg "")  
  
  
     删除图中标记的图片名称后访问，也就是访问图片所在目录，看到状态码为403，也就是说明目录存在，但是中间件做了权限限制，没权限访问  
### Web应用基础  
#### PHP与HTTP交互  
  
在PHP中，HTTP请求参数通过以下超全局变量获取：  
- **$_GET**  
：获取GET方法传递的参数  
  
```
 // URL: http://example.com/page.php?id=123&name=test    $id = $_GET['id']; // 123    $name = $_GET['name']; // test
```  
  
    比如我在本地搭建一个web服务，使用phpstudy启动  
```
<?php    $id = $_GET['id'];    if ($id==123){    echo '你好';    }    ?>
```  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRU5eoGD2iaFibK7llYChic5uGAt7ksicm3uibDUBaPEQpvjuRDgRLZNoJusQ/640?wx_fmt=png&from=appmsg "")  
    访问为空白，因为默认不打印什么东西，我们可以传入id=123打印出结果，这就是验证GET成功![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRj6sxsZf6Y4k6pib4ibk9vt6rXiav8dB4yOKFrvicbuNKN4d8CHDRkg5LOA/640?wx_fmt=png&from=appmsg "")  
**$_POST**  
：获取POST方法传递的参数  
```
 // HTML: <form method="post"><input name="username"><input name="password" type="password"></form>    $username = $_POST['username'];    $password = $_POST['password'];
```  
  
    这次将之前的GET直接改为POST发现，使用url传递参数是不可行的了  
```
<?php    $id = $_POST['id'];    if ($id==123){    echo '你好';    }    ?>
```  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRicFvgIkV28NoHagXqsDMsjo7xnSOdAFicCBQuFNa2FFXQhQyEsFm9hGQ/640?wx_fmt=png&from=appmsg "")  
  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BR6PfJ5pyiaH0BDzoL25xnqBoxtQCOe1jA6RuEzBpFR9y9LBvdZVbLWOA/640?wx_fmt=png&from=appmsg "")  
    此时使用抓包工具或者hackerbar传递POST参数可以看到又回显了，这就是POST请求，相对比GET安全一些，隐私性强一些 -![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRrRictuqOtMMQy7k2dU48MKHwpabrFTI6pNGNN2A8eax2Jg9LG8XaRcg/640?wx_fmt=png&from=appmsg "")  
  
  
$_REQUEST  
：同时包含$_GET  
、$_POST  
和$_COOKIE  
的内容  
```
 $value = $_REQUEST['param']; // 可能来自GET、POST或COOKIE
```  
  
    那么最后是request，他可以允许多种请求方式，无论是GET还是POST都可以，REQUEST之前在一些学生的CTF比赛基础中常见到  
```
 <?php    $id = $_REQUEST['id'];    if ($id==123){    echo '你好';    }    ?>
```  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRfcrJuic3EibXwWickyFGyAtWmUF5DRmXL4UDZr0CzHoNkCicibKRBB14tnw/640?wx_fmt=png&from=appmsg "")  
  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRjZHg9wGJMWCribmWCZebuSic3HibBBe7rvFykDjziaBxWGCywDS0FtCVog/640?wx_fmt=png&from=appmsg "")  
  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRjAYjpWpR7YQLYX5fqsBicYdoSLEJwsJ0z3ibueDLfIe2911IIdoiavKAQ/640?wx_fmt=png&from=appmsg "")  
  
  
**$_SERVER**  
：获取服务器和请求信息  
```
$method = $_SERVER['REQUEST_METHOD']; // 请求方法(GET/POST等)    $uri = $_SERVER['REQUEST_URI']; // 请求URI    $ip = $_SERVER['REMOTE_ADDR']; // 客户端IP地址    $userAgent = $_SERVER['HTTP_USER_AGENT']; // 用户代理(浏览器信息)
```  
  
    以上函数功能为获取客户端的一些信息，比如客户端进行了哪些操作，IP地址是多少，ua是什么，这些都是基本的，我们可以进行打印看看执行的操作  
```
<?php  $method = $_SERVER['REQUEST_METHOD']; // 请求方法(GET/POST等)  echo $method . '<br>';;  $uri = $_SERVER['REQUEST_URI']; // 请求URI  echo $_SERVER . '<br>';;  $ip = $_SERVER['REMOTE_ADDR']; // 客户端IP地址  echo $ip . '<br>';;  $userAgent = $_SERVER['HTTP_USER_AGENT']; // 用户代理(浏览器信息)  echo $userAgent . '<br>';;  ?>
```  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRapWibHYx3TfA1hxd0b3PA0aibTZLulnR0aJswib7WxLBTg3kAy4r4StVg/640?wx_fmt=png&from=appmsg "")  
  
  
    这个是我默认访问的结果，那么如果我改一下UA、请求方式  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRIZLj8ONm0KeQejorcK17hmNUNpkDllNxwmIBesheZqvj8nmVsSBr5w/640?wx_fmt=png&from=appmsg "")  
  
  
    图中我更改了UA和请求方式，响应里面就是我更改的内容了，这里我测试了伪造IP不可行  
#### Cookie与Session  
  
**Cookie**  
：  
- 存储在客户端浏览器中的小型文本文件  
  
- 在PHP中使用setcookie()函数设置，通过$_COOKIE获取  
  
```
  // 设置Cookie    setcookie("user", "john", time() + 3600, "/", "example.com", true, true);    // 获取Cookie    $user = isset($_COOKIE['user']) ? $_COOKIE['user'] : '';
```  
```
<?php    if (isset($_COOKIE['user']) && $_COOKIE['user'] === 'admin') {    echo '你好管理员';    } else {    echo '未授权访问';    }    ?>
```  
  
    正常情况下，程序肯定有更多鉴权，那么这里直接获取cookie中的user参数是否为admin用户，来模拟正常的鉴权流程，还是使用hackerbar测试![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BR20EB7V8bmWHnRseKI0kAAIwSrdGeLIOaZ1sWaqkiaEU1Akf9auSudIg/640?wx_fmt=png&from=appmsg "")  
    第一个请求cookie中的user为user用户，代表为普通用户访问![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRjI26k1lHnVSPkWeRTLDWs3Wpa2ib1uSmnvX1ibMWdKuh34jicrXB107fQ/640?wx_fmt=png&from=appmsg "")  
    那么第二个则表示了我cookie为管理员(所以这里也突出一个漏洞叫越权/伪造权限)，之前比赛也遇到过类似的，echo出flag 安全相关属性：  
- **HttpOnly**  
：防止JavaScript访问  
  
- **Secure**  
：仅通过HTTPS发送  
  
- **SameSite**  
：控制跨站请求时的发送策略  
  
**Session**  
：  
- 存储在服务器端的用户会话数据  
  
- 通过唯一标识符(Session ID)关联用户  
  
- 在PHP中使用session_start()初始化，通过$_SESSION  
访问  
  
```
  // 开始会话    session_start();    // 存储数据    $_SESSION['user_id'] = 123;    $_SESSION['logged_in'] = true;    // 获取数据    $userId = isset($_SESSION['user_id']) ? $_SESSION['user_id'] : 0;    // 销毁会话    session_destroy();
```  
  
    那么这次的测试看到，即使我们伪造cookie也获取不到管理员权限了，是因为cookie是客户端发送到服务端，而session是存储在服务端的用户会话数据，无法伪造  
```
<?php  session_start();  if (isset($_SESSION['role']) && $_SESSION['role'] === 'admin') {  echo '你好管理员';  } else {  echo '未授权访问';  }  ?>
```  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRsWbdCzn5VLTlYjK1riaa8UcShh0KHfBL88xXMNicOnDhIQGmXVYVUC6A/640?wx_fmt=png&from=appmsg "")  
  
#### 文件系统交互  
  
PHP提供了多种操作文件系统的函数，这也是安全审计中的重要关注点：  
  
**读取文件**  
```
  $content = file_get_contents('file.txt');    $lines = file('file.txt'); // 读取到数组中    $handle = fopen('file.txt', 'r');    $content = fread($handle, filesize('file.txt'));    fclose($handle);
```  
  
    以下文件中演示了任意文件读取，文件读取函数为**file_get_contents**  
```
 <?php    $filename = $_GET['filename'];    $content = file_get_contents($filename);    echo $content;
```  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRYSNR3tQ8B9ZpsvX11LI8cJCWR21aJbDric7Ht4TRv31HnTn4ZarYz2g/640?wx_fmt=png&from=appmsg "")  
**写入文件**  
```
file_put_contents('file.txt', 'content');    $handle = fopen('file.txt', 'w');    fwrite($handle, 'content');    fclose($handle);
```  
  
    如下代码中直接使用file_put_contents写入到本地一个文件，这也是任意文件写入漏洞其中一种(文件名和内容可以自定义)  
```
 <?php    $filename = $_GET['filename'];    $content = $_GET['content'];    file_put_contents($filename, $content);    ?>
```  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRffcj7eKZeK6uRZxKfaVHYYjlGWYHsYtzRriaibmtFmDaXoyLFaXlmLmA/640?wx_fmt=png&from=appmsg "")  
**文件上传处理**  
```
if (isset($_FILES['upload']) && $_FILES['upload']['error'] == 0) {    $target = 'uploads/' . basename($_FILES['upload']['name']);    move_uploaded_file($_FILES['upload']['tmp_name'], $target);    }
```  
  
    以下为任意文件上传的示例代码  
```
<?php  if ($_SERVER['REQUEST_METHOD'] === 'POST' && isset($_FILES['file'])) {  $file = $_FILES['file'];  $customName = $_POST['filename'] ?? pathinfo($file['name'], PATHINFO_FILENAME);  $extension = pathinfo($file['name'], PATHINFO_EXTENSION);  $filename = $customName . ($extension ? '.' . $extension : '');  if ($file['error'] === UPLOAD_ERR_OK) {  if (move_uploaded_file($file['tmp_name'], $filename)) {  echo"文件上传成功：$filename";  } else {  echo"文件移动失败，请检查目录权限";  }  }  }  ?>  <!DOCTYPE html>  <html>  <body>  <form method="POST" enctype="multipart/form-data">  <input type="file" name="file" required>  <input type="text" name="filename" placeholder="自定义文件名（可选）">  <button type="submit">上传文件</button>  </form>  </body>  </html>
```  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BR3yAsibRk7mqwFglLxNljDGhzbkl4Vkhz8m6Yxoer2JibwrF0j6FQIf6w/640?wx_fmt=png&from=appmsg "")  
  
#### 数据库交互基础  
  
**MySQL/MariaDB连接与查询**  
：  
  
**过程化风格**  
```
$conn = mysqli_connect('localhost', 'user', 'password', 'database');    $result = mysqli_query($conn, "SELECT * FROM users WHERE id = 1");    $row = mysqli_fetch_assoc($result);    mysqli_close($conn);
```  
  
    那么在数据库中，以上为一个简单的连接配置，我这里以本地数据库为例  
```
 <?php    $conn = mysqli_connect('127.0.0.1', 'empsys', 'empsys', 'empsys');    $result = mysqli_query($conn, "SELECT * FROM users WHERE id = 1");    $row = mysqli_fetch_assoc($result);    mysqli_close($conn);    print_r($row);    ?>
```  
  
    此处连接后以数组的形式打印，可以看到查询到admin成功![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BR5uCvSTJYkFwf8BJeEBs4ysYF1UGSichUzNaJ3ibU4iaibiaJVnnlPib9HOfQ/640?wx_fmt=png&from=appmsg "")  
    这个是固定好查询id的，所以不会存在注入，那么存在注入的是用户可控的，比如id  
```
<?php    $id=$_GET['id'];    $conn = mysqli_connect('127.0.0.1', 'empsys', 'empsys', 'empsys');    $result = mysqli_query($conn, "SELECT * FROM users WHERE id = $id");    $row = mysqli_fetch_assoc($result);    mysqli_close($conn);    print_r($row);    ?>
```  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRTNhr8ibX7Nf0X7kshYH8zTNaQF1POMX3zpCY4qG3yTHoBXnwIntm7Ng/640?wx_fmt=png&from=appmsg "")  
    这里传入一个id，那就可以看到我们可控了，实际上这就可以达到最简单的sql注入了，使用sqlmap测试  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BR9yEB9AibmJ6ZIj3AfZYyxg9ok6ibTkG8ouoSafa6iatcXHbicl6zibF6EqQ/640?wx_fmt=png&from=appmsg "")  
  
## PHP安全基础知识  
#### SQL注入相关  
  
SQL注入是指攻击者通过输入特殊的SQL语句片段来操纵应用程序的数据库查询。  
  
**危险函数/关键词：**  
- mysqli_query()、mysql_query()、mysqli_connect()  
  
- $sql  
 变量拼接  
  
- WHERE、ORDER BY、LIMIT 等SQL关键字后的变量  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRWYSiawX5usBdWjibxPcWiaMib2oicMc5KyNTeDHowVibRWXqicbAUNsLuiaqPg/640?wx_fmt=png&from=appmsg "")  
  
  
**安全替代方案：**  
- 预处理语句 mysqli_prepare()  
  
- 参数化查询  
  
- mysqli_real_escape_string() 函数  
  
#### 命令执行漏洞  
  
命令执行漏洞允许攻击者在服务器上执行任意系统命令。  
  
**危险函数/关键词：**  
- system()  
  
- exec()  
  
- shell_exec()  
  
- passthru()  
  
- popen()  
  
- proc_open()  
  
- pcntl_exec()  
  
- 反引号执行 command  
  
在以上函数中均为php中的命令执行函数  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRnBkzg1EnSNhkibLO0iaF0eUicj9NQjDyzshxicMjk3nyefR4x52ic6dLBqg/640?wx_fmt=png&from=appmsg "")  
  
  
**安全替代方案：**  
- 避免直接调用系统命令  
  
- 使用PHP内置函数替代命令行操作  
  
- 严格过滤和验证用户输入  
  
#### 文件包含漏洞  
  
文件包含漏洞允许攻击者包含恶意文件或查看敏感文件内容。  
  
**危险函数/关键词：**  
- include()  
  
- include_once()  
  
- require()  
  
- require_once()  
  
- 动态文件路径变量  
  
    那么文件包含和文件读取是两码事，文件读取是读取到文件后一般以文本的形式进行打印，上方的  
file_get_content  
也看到了，但是文件包含是在php中包含(假如文本文件也是以文本输出，但是如果包含php则会执行)  
  
    我在本地目录创建一个phpinfo文件进行包含测试  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BR0ECFmeibicQbIuh0ZMrQVXQHdcfxBpYWTtukAOZ7AMdoufibUsnjLykdQ/640?wx_fmt=png&from=appmsg "")  
  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRnOZhGyoceZ5ojMJEhyxRbjsRzv5PSzlONBCEiclV9NgfAdm6llHaIGw/640?wx_fmt=png&from=appmsg "")  
  
  
**安全替代方案：**  
- 使用白名单验证包含的文件  
  
- 避免将用户输入直接用于文件包含路径  
  
- 使用常量定义包含路径  
  
#### 文件上传漏洞  
  
文件上传漏洞允许攻击者上传恶意文件（如PHP WebShell）。  
  
**危险函数/关键词：**  
- move_uploaded_file()  
  
- $_FILES 数组  
  
- 文件类型验证不严格  
  
- 文件扩展名检查绕过  
  
**此处参考上面的任意文件上传漏洞利用，传入一个txt文件**  
  
**安全替代方案：**  
- 严格验证文件类型（MIME类型）  
  
- 重命名上传文件，使用随机文件名  
  
- 存储在网站根目录外或限制执行权限![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BR31yMDYT9OUdTVU2LClsTgk2W4ibFbMUppOTt9Z2DyQl9GLsp0RSm9KQ/640?wx_fmt=png&from=appmsg "")  
  
  
#### XSS跨站脚本漏洞  
  
XSS允许攻击者在受害者的浏览器中执行恶意JavaScript代码。  
  
**危险函数/关键词：**  
- 直接输出用户输入 echo $_GET['param']  
  
- $_GET  
、$_POST  
、$_REQUEST  
 变量未过滤  
  
- HTML内容未转义  
  
    一般出现于(搜索框、个人信息编辑等反射型XSS)(留言区、评价等insert插入数据库中的存储型xss)  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRgDB0mjJTsZic5Ns3nNq6slUTziaicFZ97j67JeLmJzVtzlwJkbTKAJFxA/640?wx_fmt=png&from=appmsg "")  
  
  
**安全替代方案：**  
- htmlspecialchars() 函数  
  
- htmlentities() 函数  
  
- 内容安全策略(CSP)  
  
#### 其他重要危险函数  
- eval() - 可执行任意PHP代码  
  
- unserialize() - 反序列化漏洞  
  
- file_get_contents() - 可读取任意文件或URL  
  
- file_put_contents() - 可写入文件  
  
- preg_replace() 带 /e 修饰符 - 代码执行  
  
- phpinfo() - 泄露服务器信息  
  
### 代码审计常用工具  
- **PHPStorm**  
 - 强大的PHP IDE，支持代码导航和搜索  
  
- **Visual Studio Code**  
 - 轻量级编辑器，有丰富的扩展  
  
- **Grep/Ag**  
 - 命令行搜索工具  
  
- **RIPS**  
 - PHP静态代码分析工具  
  
- **Fortify**  
 - 商业代码审计工具  
  
## 代码审计方法论  
### 审计准备工作  
1. **环境搭建**  
  
1. 将代码部署到本地开发环境(如XAMPP、WAMP等)**此处本地无法搭建(无SQL文件，建议审计后靶场复现)**  
  
1. 配置好数据库和相关依赖  
  
1. 确保应用可以正常运行  
  
1. **代码结构分析**  
  
1. 熟悉目录结构，了解MVC等架构模式  
  
**看目录得知为原生PHP开发(易于理解，学习建议递增式)**  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRGVfTYNn4ylknWe22j74DliaCHVhsmsAhh0IAQib4o0jcpgEgj7DicqFjw/640?wx_fmt=png&from=appmsg "")  
  
- 识别入口文件和核心框架文件  
  
- 了解配置文件和第三方库的使用情况  
  
#### 自上而下的方法  
  
从用户输入点开始跟踪数据流，适合小型项目：  
1. 识别所有用户输入点（GET/POST参数、Cookie、上传文件等）  
  
1. 追踪这些输入如何被处理和使用  
  
1. 检查是否有适当的验证和过滤  
  
#### 自下而上的方法  
  
从危险函数开始反向追踪，适合大型项目：  
1. 搜索代码库中的危险函数和关键词  
  
1. 分析这些函数的参数来源  
  
1. 判断是否存在可被用户控制的输入  
  
    这里的意思指的是：**寻找功能点，对应的找到相关的文件或者路由去跟进**  
#### 业务逻辑审计  
  
专注于业务流程中的逻辑漏洞：  
1. 了解应用的核心业务逻辑  
  
1. 检查关键业务流程的权限控制  
  
1. 分析特殊场景下的处理逻辑  
  
    这里的意思指的是：**寻找函数，比如sql连接相关特征，文件上传函数，命令执行函数，一个个去查看有没有过滤，能不能利用，一步步跟进，也是常用方法**  
## 实战：PHP电商系统代码审计步骤详解  
  
现在，我们以EshopPro电商系统为例，进行一次完整的手工代码审计。  
### 环境准备和初步分析  
  
    首先，让我们把代码加载到PHPStorm中，并进行初步分析：  
```
1. 将代码克隆或复制到本地开发环境  2. 在PHPStorm中打开项目  3. 配置PHP解释器和开发环境
```  
  
    这里我使用phpstorm进行审计，也可以使用其它编辑器比如vscode等，黑盒获取源代码直接通过扫描的方式获取备份  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRxxJZOGlsSB7SDf7oeibzicvlic3S2Mq9b775eOdbCL1nickOYFkDDmH2TQ/640?wx_fmt=png&from=appmsg "")  
  
  
**了解项目结构**  
  
    打开项目后，我们首先看到的是这样的目录结构：  
```
/  |-- admin/ # 管理后台  |-- assets/ # 静态资源(CSS/JS/图片)  |-- includes/ # 公共包含文件  |-- uploads/ # 上传文件目录  |-- user/ # 用户中心  |-- index.php # 网站首页  |-- ... # 其他页面文件
```  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRbtBt4VJdru9NKu2CnCLaWmjuR2YMfVy4vgS9O2bcibFmFpbrK1ibxsLQ/640?wx_fmt=png&from=appmsg "")  
#### 1. 后台登录点SQL注入  
  
    先以自上而下的方式进行注入，因为访问admin有后台页面，但是通过爆破确实没有办法进入后台  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRADvq4L8X5OnnRkAkDdHA9U6IribMDic7EicFzj6NhRmfkDTOpibjj3Bv6w/640?wx_fmt=png&from=appmsg "")  
  
  
    那么如果在黑盒里面，我们在这种只有登录页面的情况下，除了爆破还有看接口、前端源代码下是否有注释以及js里面是否有可以利用的东西，其它像钓鱼之类的暂且不提  
  
    但是像我们现在有源码的情况下，可以直接去对应的文件种去查看对应的代码比如sql查询  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRaxtcR5ialmPd71DUWVZLQz4ZxP7LWcxUCF7cz1O5Gf9ph2h7KBWHicibQ/640?wx_fmt=png&from=appmsg "")  
  
  
    首先映入眼帘的就是在一开始讲到的文件包含中的一个函数：**require_once**  
，它需要包含到配置文件以及功能文件的，至于为什么这样呢？其实就是因为配置文件中包含数据库配置和其它配置，以及functions中存在的一些核心功能，当包含后，可以在使用的时候直接调用，而不再需要每个文件都单独去写入数据库配置了，第一是不安全容易泄露，第二是因为造成不必要的工作量，第三是因为这样方便管理  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRfBLTiazdl9AbnQYRLhf8VOHiar6XiblmYH9St9aH7rkpmUpSkwrsI23hw/640?wx_fmt=png&from=appmsg "")  
  
  
    那么再接着往下看，第五行为一个纯文本的title也就是头部名称，然后第7-9行先进行了鉴权，也就是咱们前面了解的session，从session中获取admin_id，如果存在，那么直接跳转到index.php，这样就是如果我们是登录状态下了，即使访问登录页面，经过鉴权也会跳转到后台首页，防止死循环重定向或者使用体验  
  
    12-18行定义了一个POST传参，叫做username和passwrod也就是我们登录的时候前端传递的账号密码，然经过后面的sql语句进行处理  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRckYONHdoh0JB6KHcxJazbIevdqd4pVfZ6OJWtgZcjc5jJfaVhtUShQ/640?wx_fmt=png&from=appmsg "")  
  
  
    那么后面又做了一个判断，叫做是否为空，防止空值传入  
  
    接下往下看**19行-29**  
行开始，定义SQL语句进行查询，主要查询传递过来的账号和密码是否正确，然后查询组是否为管理员，接着交给：**mysqli_query**  
函数进行查询，所以在前面我们学习SQL注入相关的时候就有关于：mysqli_query的注意点  
  
    然后**22-23**  
行主要查询返回的结果是否为真，如果为真则开始后面的**25-29行**  
的会话创建并跳转到后台的首页  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BReVx29ibXSHmSb0xsurxk5I6gRib4DkA4F5VRwMFoAyolbW6l0DWrE0yQ/640?wx_fmt=png&from=appmsg "")  
  
  
    那么在第**31行到44行**  
实际上和前面的差不多，只不过sql语句只查询了传递过来的账号以及组是否正确，并没查询密码，也就是说如果输入了admin，密码随意，那么就可以登录后台，但是刚才测试的并没有，原因是因为程序是有上往下进行执行的，上面的程序执行成功了，则不会再往下执行，比如第30行可以看到有else语句，当前面条件没有执行成功或未满足才会执行后面的代码  
  
    接着看漏洞点：首先第一条sql语句，也就是现在使用的sql语句的漏洞点是直接获取到账号的用户名和密码进行了拼接，没有进行任何的过滤，而且攻击者可以使用语句：  
' OR 1=1 --   
进行绕过登录，也就是恒真，比如下图  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRSWYJsibTGmTSXSyQdgR3eGYdOatbuJdgfZGqGoe9pkvPjHUnT713R2Q/640?wx_fmt=png&from=appmsg "")  
  
  
那么已知原SQL语句如下  
```
SELECT * FROM users WHERE username = '$username' AND password = '$password' AND role IN ('admin', 'super_admin')
```  
  
则最终直接拼接后的语句如下  
```
SELECT * FROM users WHERE username = ''or 1=1 --' AND password = ''or 1=1--' AND role IN ('admin', 'super_admin')
```  
  
    最终带入到数据库中的sql语句如图，可以看到第一个username的--注释符将后面的语句注释掉了，达到了恒真的状态  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BR3Qk8x5Kp5kATDUQw8lug84gSnnv1KN8lQaUBCjN7nOeDh982FhfJYw/640?wx_fmt=png&from=appmsg "")  
  
  
    但是为满足前端的不为空判断，我们必须要填入值，满足登录进去的状态下，password填写同样的payload  
  
    最终sqlmap注入成功，最终写报告的时候需要的  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRa3ciaqt2cXsXPbZsc7mkyQZNCc1dmkjFMqbgTK12QJTCKf4yqFEjT5g/640?wx_fmt=png&from=appmsg "")  
  
#### 2. SQL注入-后台商品搜索  
  
    这里先不使用代码审计工具，还是手动跟进，印象更深刻，在**PHP storm**  
点击左上角的**Edit**  
->**Find**  
->**Find in Files**  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRFXSjnYGL9bFcibmbibiadIqm4fsqcpicPeKSc9HFzQia3zmdT1AM2jymc8A/640?wx_fmt=png&from=appmsg "")  
  
  
    比如跟着前面**PHP安全基础知识**  
中的方法，我要先找SQL注入，缩小范围我先找管理员后台的漏洞，那么就把目录指定到admin目录，然后一个个函数搜索如下图  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRt3lFic80CePic2cGlbPSNn2wqgibhpl8evopS9ozBlxAHfej8GiafVAadg/640?wx_fmt=png&from=appmsg "")  
  
  
    首先大部分映入眼帘的是/**admin/index.php**  
中定义的SQL语句，这里是没有注入的，因为可以清清晰看到最后的查询都是固定的，没有传入$xxx  
的参数，毕竟是首页控制台嘛，肯定有查询来显示数据的  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRIjnb6SdSZl86ic3Wydl5uBoqq016NFuBticCXRnAviamet8jFY899AMvg/640?wx_fmt=png&from=appmsg "")  
  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRed1nEicC98qjrTKeJV3oYUWdV6L7Pgnu6DOHF8vgK6AxtVQEn5GcDXg/640?wx_fmt=png&from=appmsg "")  
  
  
    接着看第二个显示出来的是admins.php文件，这个有参数传入进行拼接然后查询，但是网上追踪看到admin_id是从session里面取值，而不是完全的用户可控  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRq8RGJ0cQz3M2rorlsAFczViatSGNpgBa8n6picRFP8tRCknBfazPR6ibw/640?wx_fmt=png&from=appmsg "")  
  
  
    接着看下图中的第二个SQL语句点，是一个insert语句，但是经过审计，看  
$**admin_id**  
在前面已知是从session中取值，则忽略，然后再看delete_id是从哪来的？往上按住键盘ctrl并点击跟进，是get获取的id参数，这个id是可以通过上方构参传递的  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRhCd5qZoR5EfB7ribKzohq95z2wtt6QyomY6jDgqIrc1sqVnlxG1qh8Q/640?wx_fmt=png&from=appmsg "")  
  
  
如下图我们可以执行：  
```
admin/admins.php?action=delete&id=1
```  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRRh7B4W3PW96DBRnGKjLkxS0CmZSnq76plLZibIfnI82OejhwbiaPSXjg/640?wx_fmt=png&from=appmsg "")  
  
  
    实际上大家可能都认为存在sql注入，实际上不存在，因为在下图中的第26行后会先查询输入的id值以及是否为管理员，然后再从29行判断是否为真，接着进行delete删除，所以传入id需要是整数型，如果为其它则回显不存在  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BR7pDHsG4zxjZjx545OZm7Xibo0yxpeXlicYaWHa5t7dBjKvZmv9IDVJxA/640?wx_fmt=png&from=appmsg "")  
  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRicY97aS1Do2J3tRiawU1B0vNeQcfbV3MwQfNfibTSjmx1jOVQvjXrb2mg/640?wx_fmt=png&from=appmsg "")  
  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRBHsVTRWaCCrWN1BFLUPSicopiaVGC7iaviaiayz7qArHVWrKb8amgoliaSiaQ/640?wx_fmt=png&from=appmsg "")  
  
  
    那么有了这个思路以后，就可以继续往下审计了，这里直接切入正题，以免废话过多  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRoygyyhl3Zpy1FqmkEQRmgz5GaAria1S2ZDAPqwuicHNBUTq8xQB3RiasQ/640?wx_fmt=png&from=appmsg "")  
  
  
    上图中的  
products.php  
中有多个sql交互，点击进去一个个看  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRS5CrnBPO0dICRanPoSsBBOsU5Nj92BhdicgIgZpl5Ywtl5hOqjXbibeQ/640?wx_fmt=png&from=appmsg "")  
  
  
    第一处是删除的sql语句，但是跟进$product_id是可以发现，要求为int类型的  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRtia2gxJlUkwUwAqicic1k4P3cmPCb0L1u6lTtAwh3Q2o4SZsnHNZKaMzA/640?wx_fmt=png&from=appmsg "")  
  
  
    接着往下看，有多处case的sql语句的，其中看到有"请至少选择一个商品"，那么这个就是批量功能，对应页面如下图  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRX2Ze0xTunyJfuZcKqRXSmzxQD7jlod8oav8pHmR4qzydJsGxiay5CPQ/640?wx_fmt=png&from=appmsg "")  
  
  
    实际上跟踪一下$product_ids  
发现，25行会接收由23行定义POST传递过来的product_ids，以及action，然后$_POST['product_ids']  
包含了多个id，array_map('intval', ...)讲数组中的每个元素转为整数型，也可以防止sql注入，implode(',', ...)把经过整数转换后的数组元素用逗号连接成一个字符串  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRU7Q5CDibma4lFBtLCvJMwWvAKuJYuPeRwac6FtzBs0FvyK9MYq5P5hw/640?wx_fmt=png&from=appmsg "")  
  
  
    来到141行和145行处，看到可控参数  
$where_clause  
跟进，看到代码：  
```
$where_clause = !empty($where_conditions) ? "WHERE " . implode(" AND ", $where_conditions) : "";  // 作用是依据之前收集的筛选条件数组，生成 SQL 查询里的 WHERE 子句部分
```  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRnXyovJaibwONArZFXsibzbYuHSJFWSiagXAH4JibRHmHUVspKdpwmuErPQ/640?wx_fmt=png&from=appmsg "")  
  
  
    继续跟进代码里面的$where_conditions，然后看到存储sql的where条件  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BREWmlL8fS3wM09W9o6uggDgNCcoRrcREQA9yy00DicvVfU7AvzXnk1oA/640?wx_fmt=png&from=appmsg "")  
  
  
往下看，下面的代码是什么意思  
```
$where_conditions = []; // 存储SQL WHERE条件  $params = []; // 存储URL参数（用于分页链接）  if ($category_id > 0) {  $where_conditions[] = "p.category_id = $category_id";  $params[] = "category=$category_id";  }  // 状态筛选（active转为1，其他转为0）  if ($status !== '') {  $status_value = ($status === 'active') ? 1 : 0;  $where_conditions[] = "p.status = $status_value";  $params[] = "status=$status";  }  // 特色商品筛选（-1表示不筛选）  if ($featured >= 0) {  $where_conditions[] = "p.is_featured = $featured";  $params[] = "featured=$featured";  }  // 关键词搜索  if (isset($_GET['keyword']) && $_GET['keyword'] != '') {  $unsafe_keyword = $_GET['keyword'];  $where_conditions[] = "p.name LIKE '%$unsafe_keyword%'";  }
```  
  
    那么这个就是搜索商品的功能然后进行排序，在这里面，其它要不然就是不可控，要不就是只能数字型，但是有一个  
是可控的，这个是传参进来的，然后直接拼接到语句，  
unsafe_keyword%'";，%在MySQL中称为通配符，like为模糊搜索，比如搜索手机，那么最后查询的可能是小米手机、手机壳，因为定义的是  
%$unsafe_keyword%  
，也就是%手机，左右都可以，这里我们就可以构造payload，  
%' OR 1=1 --  
也是恒为真的语句，最后构成的sql语句为  
```
WHERE p.name LIKE '%%' OR 1=1 -- %'SELECT p.*, c.name as category_name  FROM products p  LEFT JOIN categories c ON p.category_id = c.id  WHERE p.name LIKE '%' OR 1=1 -- %'  ORDER BY p.id DESC%' OR 1=1 --
```  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BR0smyIiauCHicQFmSJgRyZhNoALaDjXL40gtvGph0ebprth2lOLM1icJvQ/640?wx_fmt=png&from=appmsg "")  
  
  
    由于恒为真，最后查询到所有的商品，里面的limit失效是因为--进行注释了  
  
    验证以后上sqlmap最终获取到此位置的sql注入漏洞点  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRBz4HXv5DXEEtEMW0U3MPyRvwntrC04f3gib25HGwedIZQC2JpLibjnmQ/640?wx_fmt=png&from=appmsg "")  
  
#### 3. 前台SQL注入漏洞  
  
    已经找到了后台的，我们需要对比一下前台和后台的区别有哪些？(后台可能还有其它漏洞，可以自行去挖掘)  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BR50qPv68bBOq9jp1eJDVheLcsHpnYuz9xudXIAzMu6CpxzzzTXpR9qA/640?wx_fmt=png&from=appmsg "")  
  
  
    比如我现在在没有登录的情况下进行了搜索功能，看一下search.php和后台文件的区别，比如鉴权  
  
    前台：**search.php**  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRzW5traiaf0BU4FPtxzdoYZ6wlva88WuDEo6s1DAeVWslYZPaFlVkqicQ/640?wx_fmt=png&from=appmsg "")  
  
  
    查看文件只包含了一个header.php文件，后面就传递keywork参数，以及其它参数和开始后面的程序逻辑  
  
    查看user/profile文件后看到第八行有鉴权代码is_logged_in  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRiaycSTly6w4CSyY4PDKKgpcDJwZdwVBxic3rZVOia4an3Xuwyyt6yaKsg/640?wx_fmt=png&from=appmsg "")  
  
  
    这就是判断是否为前台还是后台的区别  
  
    随机挑选一个前台的文件，比如login.php，登录处有sql语句，查询账号这里存在sql注入  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRbWFFSpicOiaE6PM8ywibB6icJngcpd98nvXt1sQOn5jGiaOzdz1L4hxGibsg/640?wx_fmt=png&from=appmsg "")  
  
  
    直接拼接用户到sql语句中，所以还是可以构造  
' or '1'='1  
进行绕过，但是password需要使用MD5进行校验，而且密码不能为空，所以即使绕过账号鉴别，密码无法绕过  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRS1njwZZJXSfcBCUOHjSNqDRhREdMOjKWthribxXdTQhDqFibbl50P84g/640?wx_fmt=png&from=appmsg "")  
  
  
    接着看pay.php中第8-11行为鉴权，然后22行有个sql语句其中的order_id可控，跟进后发现为GET传入，不过这里也没有SQL注入或者绕过  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRTQK2dJemtE4JUf0hS1bDdibpOiaBS5TPqLrR9aIjqbu8ibjYqqzVyppyA/640?wx_fmt=png&from=appmsg "")  
  
  
    因为在第20行有intval进行了类型转换，不过也有可能绕过注入，这里不再研究  
  
    继续找到前台的**search.php**  
文件第56行中的函数往上跟进，其中的$sql_data  
为最终拼接的sql语句，跟进$base_sql  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRXUPbVoiasbacq7H8jCsj5UIqFajrU9YvNAKDgClfOoAmXvibJXf10ArQ/640?wx_fmt=png&from=appmsg "")  
  
  
    定位到第46行的语句，其中又定义了一个查询语句，可控参数$where_clause  
，接着跟进  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRHJvPWrCWDedibcQZNV3XO9tZpvhylpPuCTJvJOUrbLIdEopca1tEfFA/640?wx_fmt=png&from=appmsg "")  
  
  
    到44行，接着跟进$where_conditions  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRcqbgJiabjuibsEk5pxSzxAdbEaJJQ6luMWdTDvicKPH0vjeKric2mzpCAA/640?wx_fmt=png&from=appmsg "")  
  
  
    跟进到35行开始定义数组，37行接收来自35行的keyword参数，和前面的后台商品搜索一样，也是直接拼接进去的以%进行通配查询  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRs4jhqlKaD9PVqgSoWP29FRN8SQ0E6vdvj4PVsCqsWLE7qibeAuakx1g/640?wx_fmt=png&from=appmsg "")  
  
  
    然后第44行开始拼接，后面进入正常的数据查询流程，所以注入参数就是keyword  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRoDSGcbhXiawm9V2md32BoM5vPia7BcZticdtc1OA6J3nulrdqZYRA9YZQ/640?wx_fmt=png&from=appmsg "")  
  
  
    这次还想用之前的  
%' OR 1=1 --  
进行恒真，最后不行  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRqiaqhSf6ecADOiaQRgtRQRlIAt0lRo0wZJiaibvVLTqeUMGcq1amUabGxw/640?wx_fmt=png&from=appmsg "")  
  
  
    最后看到第114行使用htmlspecialchars进行了转义  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRlTok1iaNmYjyHj3qtbDzzMibSnBg6DuV2nLNzLTJxic8aP5GV3Md9uaHQ/640?wx_fmt=png&from=appmsg "")  
  
  
    但是已知存在sql注入，直接使用sqlmap测试就行了，已知search.php为前台文件，所以直接指定url就行了  
```
python sqlmap.py -u "http://111.119.241.115:18866/search.php?keyword=*" --batch --dbs
```  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRDA9gcKQJIHNL3A5tlQlcxyicndGxJlj1qJPqE4s7sU4NwUgf9FGsq8A/640?wx_fmt=png&from=appmsg "")  
  
#### 4. 搜索入口存在XSS注入  
  
    其实这个用黑盒测是最方便的，但是由于需要提交问题代码块，我们先进行验证  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BR7PKr7D4m7L8iaG3zwnbHuZBqcf3oTc9U4AzIt8OTGI4m2Fhk0W8RB7Q/640?wx_fmt=png&from=appmsg "")  
  
  
    定位到搜索框，后看到前端代码  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRmH313I2TycCxdjuImFicnIke6gp48jUzCc4P0iarLBM0bUnbHQSr2C4Q/640?wx_fmt=png&from=appmsg "")  
  
  
    但是呢，我们通过php看到，明明已经使用htmlspecialchars进行转义了，为什么还是会触发xss？  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRCxm2RCB8ZFmVzFI19R6krX3IVhuaNbD4F98h1KFUUvQQc91q8LZQ0Q/640?wx_fmt=png&from=appmsg "")  
  
  
以下为豆包给到的回复  
```
htmlspecialchars 函数如果没有正确设置参数，可能无法完全转义。它的完整用法通常是 htmlspecialchars($string, $flags, $encoding, $double_encode) ，若没指定 $flags 为 ENT_QUOTES 等合适值，对于单引号、双引号等处理可能不彻底。
```  
#### 5. 商品评价功能存在XSS注入  
  
    还是以黑盒的角度挖，这样更好的排查，前面提到过，存储XSS会在比如论坛、评价等经输入后存储到数据库后，然后经过select查询前端又没有完全的转义的情况下展现出来，造成存储XSS  
  
    比如在此靶场系统中，我们可以找到留言、评价、聊天等功能，由于注册账户后送余额，先看购买这里  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRVeSvdJZX5H6XvDtwHm8Y2XrBhNuRLYYicnLyyJA3gEoO2q9Evu5Eddg/640?wx_fmt=png&from=appmsg "")  
  
  
    那么就不得不提到之前遇到的一个问题了，在购买的时候 ，提交订单的请求包中，为什么只有我填写的信息，而没有订单信息？尽管右侧显示了购买的商品  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRg5jHYkIjKP3Iicg3p9zDqPLLIBtzm7MFqNc1bDVazxQlcGFfTmFGBPA/640?wx_fmt=png&from=appmsg "")  
  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BR7mXkCKBhzicF4klzwNfXBqBMDW3D0ic4sWnKM4kBLeIse5YiaHZhouVGg/640?wx_fmt=png&from=appmsg "")  
  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRR4hgBVDunjx6FL6JibaBOSI6o9d15ejBj8cCcZZaVDvrY9zCoo9hL9Q/640?wx_fmt=png&from=appmsg "")  
  
  
    好的，开始解答，这里的开发是无论用户点击了加入购物车还是点击购买的那一刻，系统会发送/cart_update.php?action=buy_now&id=55&quantity=1  
的请求包将商品id+个人信息加入到数据库中的购物车数据表，在支付的时候会根据session查询此人在购物车数据表中有哪些商品，在支付的时候页面后端会查询cart表然后展示出对应的卡片到前端，所以请求中不会显示任何商品信息，防止被篡改  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BReicdATyaia9QaLAwFf3ib5w1rNfsTpQUuF6vyhVmzvsnXfvQic9B5XXibOw/640?wx_fmt=png&from=appmsg "")  
  
  
    那么我们使用余额购买，因为其它两个接口是模拟的，没有支付状态，没有扣款成功，就会变成待支付状态  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BR8oMQ8dvWyXzP2j8pCmCxXsc8ZiciaKofticpTsMtpRQBlH80UDI9AoWXg/640?wx_fmt=png&from=appmsg "")  
  
  
    再次使用余额进行提交后，来到订单详情页面看到已支付  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRZ8P8xBMOvfJRYeVicyF9zZFrMFo3HnQGxNrJtvaosho886G0BQicPyMA/640?wx_fmt=png&from=appmsg "")  
  
  
    接着在商品评价处点击去评价，然后输入<script>alert(document.cookie)</script>  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRfJm8iadVRfXyWPicW3vFNsGdnA1jqR9iacm5aicd34v3icmKwV7wk6zibImA/640?wx_fmt=png&from=appmsg "")  
  
  
    那么来到对应的商品页面之后呢，就可以看到进行了弹窗  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRVJqaqNs8GkXCxd6Aq5N4E2SwXQ2dqDp8zia7DbiaVAOIPAgtFHv3YpcQ/640?wx_fmt=png&from=appmsg "")  
  
  
    回到评价页面，看看是哪个文件？然后进行对应的审计user/reviews.php  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BR7dgesCtptHcTtQxbBQ9QoiavAdmfn0iaMXPKXAQLW7SIHQxEYicZZ5PWQ/640?wx_fmt=png&from=appmsg "")  
  
  
    看到页面代码过多没有思路，这里有个思路：首先存储XSS满足肯定需要先插入到数据库，然后再有对应功能去查询，插入语句是什么？当然是insert，那么直接在页面搜insert，看看是对应的参数  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BR9VZSbzdzCXXgyJyk9p23xibA23wDyMD6q2MHM6DptsqU3QDzu8QB9jg/640?wx_fmt=png&from=appmsg "")  
  
  
    分析下图第91行为定义的insert语句，93行获取传入的数据，获取了哪些？user_id：个人信息(跟进后为session取值)，order_id(订单编号)，rating(跟进后发现是星级)，content(评价内容)，image_json(上传图片)  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRq1JHeB6C9CGJDSw2SWCyE1MTpbtZibz2B69O2mAbNtSOgHMYpj7K9Jw/640?wx_fmt=png&from=appmsg "")  
  
  
    那么ctrl接着往上跟进，看看这些参数，23-27行为定义传入的参数，29-38行为对传入的值进行判断，41-46行为鉴别此订单是否和用户一致以及是否已评价  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRp5uPN4TPeSrL758m2T0mYCa1eeFk90tDelWSCmP4gYPeT73NrNiclYA/640?wx_fmt=png&from=appmsg "")  
  
    再往下就是文件上传的逻辑，图片上传进行了白名单，大小，以及重命名限制操作  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRGeoGGzibiaUYamJH50axX1OGMqcPv7ranezkJ6q5zZsXssKnC7rRhchA/640?wx_fmt=png&from=appmsg "")  
  
  
    最终没有发现对文本进行处理和转义的操作，那么漏洞点触发就是$content  
，传入的值直接插入了数据库  
  
    接着再看商品页面为什么触发了？商品对应的PHP为product.php，由于前面评价插入的是reviews表，那么这个PHP文件肯定也是去这个表查询的  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BR6L1qDZYFkpVpicxYaGtXicuIXPo3w3LldktIlRkzCozwFs8KvlvAkfbw/640?wx_fmt=png&from=appmsg "")  
  
  
    在258行看到确实有对应的表查询并排序，最终输出打印也没有任何的转义操作  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRgBBkkRicu1u9uLcPZjPb6a0hTpzM8yGECan97bs88IyFox3MtdEd2lQ/640?wx_fmt=png&from=appmsg "")  
  
#### 6. 逻辑漏洞-订单越权遍历  
  
    这个非常建议黑盒挖完去对应的文件看逻辑，因为越权、逻辑漏洞代码审计我自己感觉比那些常规的要难一些，所以采用自上而下的方式进行挖掘，当然这也是电商平台的主流漏洞  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRxS20LYeuJ4yKGAqzu2AKHuEIiaXPfR7eqIglBlZEfqaAtjVe2GmcMuQ/640?wx_fmt=png&from=appmsg "")  
  
  
    在订单详情页面order_details.php有order_id参数，看到为id，可以尝试进行枚举，在实战中看到id或者编码也可以尝试枚举，都有意想不到的收获  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRR3jnRQuicp4opjUg7d0BWNvSkhfEaNWjcygZno1WDeRXt2pqEiamorpQ/640?wx_fmt=png&from=appmsg "")  
  
  
    使用burp去遍历一遍，这一般就是高危了，但是如果是src，那就得看人家怎么看待了，比如内部已知  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRGJMC4QhXLjrFoYOt4WYbzZr1fZbQn7HoBMFT5vicRlPw65ibwfibxcFgA/640?wx_fmt=png&from=appmsg "")  
  
  
    好的，文件为user/order_details.php  
，去对应的文件去看逻辑  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BR6Vhq4Ezxeg6obordsACqpNibzZZQUwxUfhpCIMl9jBWAqc5MEw6ibnEg/640?wx_fmt=png&from=appmsg "")  
  
  
    代码很少，进来就可以看到14行定义GET传入order_id，然后传给对应变量后直接去数据库查询，这里没有从session中获取user_id，然后去数据库中做对比，造成了越权查询  
  
    那么以后在我们做黑盒挖到了类似的漏洞，是不是就有对应的书写修复方案或者思考代码怎么写的思路了呢？  
#### 7. 任意文件上传漏洞  
  
    那么来到其它审计过程，在之前我们提到了文件上传、文件包含、命令执行等一些函数，我们可以尝试搜索  
  
    经过搜索命令执行的函数一个没有，但是有文件上传的函数，依次点击看看  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BREWe5NibQd8b2ZtuHZSA3iaV3RJ1UBq53Q0d8yLPQXnfy2gR435AibHvkg/640?wx_fmt=png&from=appmsg "")  
  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRH8RDRg6f1eZA0oW2UAlRiaF6abqicLAPX3qkZ01I8JlGQicG829vJd0ew/640?wx_fmt=png&from=appmsg "")  
  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRXhosIYotziaxUZUHu46s1H6OxiaUyLcGUY4LG82Yn4LzFKlaskl3cbjg/640?wx_fmt=png&from=appmsg "")  
  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRoWViaP1qAmn6ic2AFuE1zYFQvAlRNJtK8Mk8ic2b5KG9aBvlzGFVvdXAg/640?wx_fmt=png&from=appmsg "")  
  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRAJHNKhdqYuibvuw3e3FziaGxaEplcX6TDmat2b66Z9WELMpFibF7NqVCQ/640?wx_fmt=png&from=appmsg "")  
  
  
    在/admin/product_add.php  
看到有疑似上传文件没有过滤，和其它文件严格过滤有很明显的区别  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRvMyBdcBnOAjCs3EB9IicA9cEoaFtrGl1ScZCeTjlH5PISkictww5Hypg/640?wx_fmt=png&from=appmsg "")  
  
  
    在57行处看到有这个函数的调用，然后往下固定了路径，跟进$file_name发现是49行传来的image，47行定义了传入规则，最后看到文本提示这个功能是商品主图  
  
    那么就直接访问这个文件，随意写什么东西  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRTJj64bicjWpxJBMJVrD3vva6YCuKrAxZquo69jdYUicpiamGwE6BknKIw/640?wx_fmt=png&from=appmsg "")  
  
    这里正常抓包，上传一个正常的图片，然后前端拦截进行修改，我就不在本地写马了  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRMicbbnwnbMNSZvc1Ogk3Ta5SPnLgzCk4DJyNWHgWIlGhp1JNXqh5Umw/640?wx_fmt=png&from=appmsg "")  
  
  
    直接放包后，前端正常不回显路径的  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRpB4Reiboue8HD6VNRWOCE9iaSM2rIjn9FFIwMabTFEAFkIkU79BZbsqA/640?wx_fmt=png&from=appmsg "")  
  
  
    由于是添加商品，肯定就有商品管理，那么找到这个功能，找到刚才上传的所谓图片  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRzAqym7uZ3yf6FVnqkoQRmqmvRDl1mxHZBOXwAELAktbPNW2Z6zZ7rw/640?wx_fmt=png&from=appmsg "")  
  
  
    右击复制链接后，访问地址，看到phpinfo被执行  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRnyo5GCIysHkOibbvGPTcQouWM2dXsdnWMYWYoBIQiaYhvA8lJiaKnpTPg/640?wx_fmt=png&from=appmsg "")  
  
  
    那么这就是原生PHP开发的一个弊端，有时候可能会有疏忽，导致功能被遗漏，需要一个个去定义，也就是前面讲到的类似于每个文件单独定义MySQL密码一样，倒不如直接写一个文件去包含然后调用  
#### 8. 组合拳RCE  
  
    检查其它文件目前没发现有文件上传的漏洞了，但是大家明眼都能看出来，程序只对文件外部进行了检测，没有对里面内容进行检测，也就是说，假如我们文件上传的图片里面有PHP代码，然后利用之前学到的文件包含是否可以进行组合拳打法呢？  
  
这里我们搜索  
- include()  
  
- include_once()  
  
- require()  
  
- require_once()  
  
    通过搜索函数，找到在admin/export.php中的71行有一个文件包含函数  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRqWiabaNDoy2TyQUickzLEQ3tJnHlCh6ISwsNiaa67jxfEotA6X4BsemWA/640?wx_fmt=png&from=appmsg "")  
  
  
    这里就很微妙，首先跟进71行的$template_file  
会发现它在66行将运行目录设置在了与admin平级的目录，然后去接收$type_param  
，然后接着跟进发现，它可以直接GET传入，用户可控  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRvBtRibZVsDfkAPVMugwourwR59q1BVicHvRjqAWQpIUDic0pib1j3DwfLA/640?wx_fmt=png&from=appmsg "")  
  
  
    接着去看下图中的截图，在这个程序附近的运行逻辑  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRT7VVDQYMiaYL6ssSPbwfRJ3MpFPhl1m0q38gDAwOCWOic9whiayB6xWPA/640?wx_fmt=png&from=appmsg "")  
  
  
    检测传入的type是否按照规定的那样传入的，否则告知导出模板不存在，如果是，则调用：export_templates目录下的php文件模板导出，这里其实可以防止文件包含的，但是下面的一部分文件包含代码(**漏洞点**  
)就不该有，给的权限太大了  
  
    然后接着我们之前说的，文件上传并没有检测内容，那么在上传图片的时候插入PHP代码，比如前台登录用户后，上传头像  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BROHqE4bibsHBgCicDFune6ZwpZmA8PYjoOJYibNgVTw0roAX31IMJoNLrA/640?wx_fmt=png&from=appmsg "")  
  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRVEYCQJH5AjwxVXibf9t6qZfK97S5wKN3wMjK6GNJ2SWaaMLW93pFc9A/640?wx_fmt=png&from=appmsg "")  
  
  
    同样的方法，右键头像复制链接，这个时候访问肯定是不可以执行php代码的  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRZBBEUmXZza1rSIp3fTKGzPYF1BIYoc9jbEK2sPEVhUWb1oUjdWR26Q/640?wx_fmt=png&from=appmsg "")  
  
  
    前往后台构造以下payload：  
```
http://111.119.241.115:18866/admin/export.php?type=assets/uploads/avatars/a52a11aa8fad3017c1295145272d9f98.jpg
```  
  
![fig:](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRkAAorAsmBFeKYG5npww79DMhxA4oZNRyticSLzH6ibewKaB7F3uIZzJg/640?wx_fmt=png&from=appmsg "")  
  
    什么原理？因为前面讲过，文件包含遇到文件内存在PHP代码的时候会自动对那部分代码做执行处理  
## 结语  
  
    那么在最后呢，我想说，本系统还是有很多漏洞的，更多的漏洞需要大家去挖掘，答案仅供参考，思路仅供参考，如果在实战中可以拿着这个思路去思考，开发是怎么做的，我应该怎么通过页面的回显去进一步的漏洞挖掘，**渗透测试永远没有固定打法和思路**  
，一个站点每个人永远有不一样的思路，渗透测试的意义就是这样  
  
    其次就是最后再说一句，为什么我要讲原生PHP？因为原生的好入门，上来就讲路由，很多人是不明白的，稀里糊涂的，学习需要循序渐进的，不要今天学渗透，明天学应急，后天学物联网、免杀，勤学是好事，但是不专一就不太好了  
  
![](https://mmbiz.qpic.cn/mmbiz_png/icdGEWOnYLpNZgJEwwHVpOzOZoz9Ae9BRTIwEOleKcIvM5z8AyTMnWdibRAp81Rw3NeZib4TTkmK8icj1NkV3GZJyQ/640?wx_fmt=png&from=appmsg "")  
  
